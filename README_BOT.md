```md
# README_BOT — как работает Telegram-бот календаря

Документ описывает **исключительно работу телеграм-бота**:
команды, диалоги (FSM), форматы сообщений и inline-кнопок,
взаимодействие с БД, учёт статистики, приглашения на встречи,
обработку ошибок и логи.

> Веб-часть (Django: админка, модели, миграции, REST-задел) описана
> в `README_DJANGO.md`. Общий обзор проекта — в `README.md`.

---

## Оглавление

- [Краткое описание](#краткое-описание)
- [Архитектура бота](#архитектура-бота)
  - [Основные файлы и пакеты](#основные-файлы-и-пакеты)
  - [Зависимости](#зависимости)
  - [Обзор потоков](#обзор-потоков)
- [Конфигурация и запуск](#конфигурация-и-запуск)
  - [`bot_secrets.py` и пример](#bot_secretspy-и-пример)
  - [Параметры подключения к БД](#параметры-подключения-к-бд)
  - [Запуск бота](#запуск-бота)
  - [Меню команд](#меню-команд)
- [База данных: какие таблицы использует бот](#база-данных-какие-таблицы-использует-бот)
  - [`users`](#users)
  - [`events`](#events)
- [Команды бота](#команды-бота)
  - [`/start`, `/help`](#start-help)
  - [`/register`](#register)
  - [`/login`](#login)
  - [`/calendar`](#calendar)
  - [`/create_event` (FSM)](#create_event-fsm)
  - [`/display_events`](#display_events)
  - [`/read_event <id>`](#read_event-id)
  - [`/edit_event` (одной строкой или FSM)](#edit_event-одной-строкой-или-fsm)
  - [`/delete_event` (одной строкой или FSM)](#delete_event-одной-строкой-или-fsm)
  - [`/invite` (FSM приглашений)](#invite-fsm-приглашений)
  - [`/cancel`](#cancel)
- [FSM — состояния, переходы, отмена](#fsm--состояния-переходы-отмена)
  - [Структура хранения FSM](#структура-хранения-fsm)
  - [Состояния для создания события](#состояния-для-создания-события)
  - [Состояния для приглашений](#состояния-для-приглашений)
  - [Единые правила валидации даты/времени](#единые-правила-валидации-датывремени)
- [Встречи (Appointments): логика бота](#встречи-appointments-логика-бота)
  - [Проверка занятости участника](#проверка-занятости-участника)
  - [Создание приглашения](#создание-приглашения)
  - [Уведомления и inline-кнопки](#уведомления-и-inline-кнопки)
  - [Подтверждение/отклонение](#подтверждениеотклонение)
  - [Ошибки доставки сообщений](#ошибки-доставки-сообщений)
- [Учёт статистики (BotStatistics)](#учёт-статистики-botstatistics)
- [Логирование](#логирование)
- [Примеры сценариев](#примеры-сценариев)
  - [Создание события (FSM)](#создание-события-fsm)
  - [Редактирование одной строкой](#редактирование-одной-строкой)
  - [Удаление (FSM)](#удаление-fsm)
  - [Приглашение на встречу (FSM + inline)](#приглашение-на-встречу-fsm--inline)
- [Диаграммы](#диаграммы)
  - [Последовательность действий (sequence)](#последовательность-действий-sequence)
  - [Состояния приглашений (state)](#состояния-приглашений-state)
- [Обработка ошибок](#обработка-ошибок)
  - [Ошибки ввода](#ошибки-ввода)
  - [Ошибки БД](#ошибки-бд)
  - [Ошибки Telegram API](#ошибки-telegram-api)
- [Тестирование](#тестирование)
- [Требования к стилю и качеству кода](#требования-к-стилю-и-качеству-кода)
- [Частые вопросы](#частые-вопросы)
- [Чек-лист разработчика](#чек-лист-разработчика)
- [История изменений (кратко)](#история-изменений-кратко)

---

## Краткое описание

Бот помогает пользователю управлять личными событиями (создание, просмотр,
редактирование, удаление) и **назначать встречи другим пользователям** на
базе созданных событий. Реализовано:

- проверка занятости участника на дату/время;
- создание приглашения со статусом **ожидается (pending)**;
- отправка участнику уведомления с inline-кнопками **«✅ Подтвердить»** /
  **«❌ Отклонить»**;
- изменение статуса на **подтверждено / отклонено / отменено** и уведомление
  организатора;
- суточная статистика бота (`BotStatistics`) и персональные счётчики пользователя (`TgUser`).

---

## Архитектура бота

### Основные файлы и пакеты

```

project/
├─ bot.py                      # точка входа бота: Updater/Dispatcher, регистрация хендлеров, меню
├─ db.py                       # psycopg2: подключение и CRUD users/events (общая Postgres с Django)
├─ bot_secrets.py              # API_TOKEN (не коммитим; см. secrets_example.py)
├─ secrets_example.py          # шаблон для bot_secrets.py
└─ tgapp/
├─ **init**.py              # пояснительный docstring пакета
├─ core.py                  # общие сервисы: логгер, трекинг статистики, меню команд, ensure_* функции
├─ fsm.py                   # простая in-memory FSM + парсеры даты/времени
├─ handlers_events.py       # хендлеры событий (create/read/edit/delete, login, calendar, text_router)
└─ handlers_appointments.py # хендлеры приглашений/встреч (FSM + inline callback)

````

**Ключевые идеи**
- **Тонкий `bot.py`**: только сборка и запуск, бизнес-логика в `tgapp/*`.
- **Разделение обязанностей**: события/пользователи через `db.py`; встречи/статистика — через Django ORM.
- **FSM** — в памяти процесса, без внешнего состояния (достаточно для учебного проекта).

### Зависимости

- `python-telegram-bot==13.x` (Updater/Dispatcher API)
- `psycopg2-binary` (подключение к PostgreSQL)
- `Django 5.x` (импортируется для статистики и встреч)
- `djangorestframework` (задел под будущие REST-эндпоинты)
- стандартный `logging`

### Обзор потоков

- **События**: бот ↔ `db.py` ↔ PostgreSQL (таблица `events`)
- **Встречи**: бот ↔ Django ORM (`Appointment`) ↔ PostgreSQL
- **Статистика**: бот ↔ Django ORM (`BotStatistics`, `TgUser`) ↔ PostgreSQL

---

## Конфигурация и запуск

### `bot_secrets.py` и пример

Создайте `bot_secrets.py` на основе `secrets_example.py` и укажите токен:

```python
# bot_secrets.py
API_TOKEN = "1234567890:ABCDEF..."
````

`bot_secrets.py` добавлен в `.gitignore` и не коммитится.

### Параметры подключения к БД

`db.py` содержит `get_connection()` с параметрами подключения
к общей PostgreSQL (совместно с Django). Проверьте имя БД,
пользователя и пароль перед запуском.

### Запуск бота

Из **корня** проекта:

```bash
python bot.py
```

> Важно запускать из корня, чтобы корректно резолвились импорты
> и `DJANGO_SETTINGS_MODULE` указывал на `webapp.settings`.

### Меню команд

`/start`, `/help`, `/register`, `/login`, `/calendar`,
`/create_event`, `/display_events`, `/read_event`, `/edit_event`,
`/delete_event`, `/invite`, `/cancel`.

Меню настраивается при старте (`setup_bot_commands` в `tgapp/core.py`).

---

## База данных: какие таблицы использует бот

Данные хранятся в **PostgreSQL**. События и пользователи бот пишет
через **psycopg2** (`db.py`). Django читает **те же** события через
ORM-модель `Event (managed=False)`.

### `users`

Минимальные поля (вариант учебного задания):

* `tg_user_id BIGINT PRIMARY KEY`
* `username TEXT NULL`
* `first_name TEXT NULL`
* `created_at TIMESTAMP DEFAULT now()`

Используется `/register` для идемпотентной регистрации.

### `events`

Поля:

* `id SERIAL PRIMARY KEY`
* `name VARCHAR(255) NOT NULL`
* `date DATE NOT NULL`
* `time TIME NOT NULL`
* `details TEXT NOT NULL DEFAULT ''`
* `user_id BIGINT NOT NULL` — владелец (Telegram ID)

**Важно:** таблица **общая**. Бот пишет сюда напрямую (psycopg2),
Django видит её через `Event(managed=False, db_table="events")`.

---

## Команды бота

### `/start`, `/help`

Краткая справка по доступным командам (см. `handlers_events.start/help_command`).

### `/register`

Идемпотентно создаёт пользователя в `users`. Если запись уже есть —
возвращает подтверждение без ошибки. Параллельно синхронизируется профиль `TgUser`.

### `/login`

Привязывает текущий Telegram-аккаунт к модели `TgUser` (создаёт/обновляет карточку).
Нужно для «личного кабинета» в админке и для персональных счётчиков активности.

### `/calendar`

Показывает личный календарь пользователя (через ORM `Event` по `tg_user_id`).
Выводится список событий с датами/временем/названием и описанием.

### `/create_event` (FSM)

Пошаговый диалог создания события:

1. `WAIT_NAME` — название
2. `WAIT_DATE` — дата `YYYY-MM-DD`
3. `WAIT_TIME` — время `HH:MM`
4. `WAIT_DETAILS` — описание
5. Вставка в БД и ответ с ID; обновление счётчиков/статистики.

При неверном формате даты/времени — просьба повторить ввод.

### `/display_events`

Выводит список событий пользователя (через `db.py`):

```
[ID: 1] Брифинг — 2025-12-10 10:00
[ID: 2] ...
```

### `/read_event <id>`

Показывает подробности **своего** события по ID (чужое — недоступно).

### `/edit_event` (одной строкой или FSM)

* **Одной строкой:** `/edit_event <id> <новое описание>`
* **FSM:** без аргументов:

  * `WAIT_ID` → ранняя проверка владения → `WAIT_NEW_DETAILS` → запись → «Обновлено»
* При успехе обновляются счётчики и статистика.

### `/delete_event` (одной строкой или FSM)

* **Одной строкой:** `/delete_event <id>`
* **FSM:** `WAIT_ID` → удаление → «Удалено»
* При успехе обновляются счётчики и статистика.

### `/invite` (FSM приглашений)

Диалог приглашения участника на **ваше** событие:

1. TG-ID участника → 2) ID вашего события → 3) детали/«Пропустить».

Проверки:

* событие принадлежит организатору;
* участник свободен в дату/время события.

Если свободен — создаётся `Appointment(status=pending)`,
участнику отправляется сообщение с inline-кнопками **✅/❌**,
организатору — уведомление об ожидании ответа.

### `/cancel`

Отмена **текущего** диалога (FSM) и очистка состояния.
Также доступна кнопка «Отмена» (ReplyKeyboard).

---

## FSM — состояния, переходы, отмена

### Структура хранения FSM

FSM хранится в памяти процесса:

```python
user_states = {
  tg_id: {
    "flow": "CREATE" | "EDIT" | "DELETE" | "INVITE",
    "step": "...",
    "data": {...}
  }
}
```

Операции: `set_state`, `get_state`, `clear_state` — см. `tgapp/fsm.py`.

### Состояния для создания события

`CREATE`:

* `WAIT_NAME` → `WAIT_DATE` → `WAIT_TIME` → `WAIT_DETAILS` → INSERT

Парсинг даты/времени — `parse_date/parse_time` из `fsm.py`.

### Состояния для приглашений

`INVITE`:

* `INVITE_WAIT_PARTICIPANT` → `INVITE_WAIT_EVENT_ID` → `INVITE_WAIT_DETAILS` → создание `pending`

### Единые правила валидации даты/времени

* Дата: `YYYY-MM-DD`, пример `2025-12-12`
* Время: `HH:MM`, пример `09:05`
* Сообщения об ошибке — единообразные.

---

## Встречи (Appointments): логика бота

### Проверка занятости участника

`calendarapp.utils.is_user_free(tg_user_id, date, time)`:

* если есть `pending`/`confirmed` встречи на слот — участник **занят**,
* иначе — **свободен**.

### Создание приглашения

`calendarapp.utils.create_pending_invite_for_event(...)`:

* валидация владельца события (ID должен быть вашего события),
* проверка занятости,
* создание `Appointment(pending)` с копированием даты/времени события,
* возврат объекта встречи и рассылка сообщений.

### Уведомления и inline-кнопки

Участнику: текст приглашения + inline-кнопки:

* **✅ Подтвердить** → callback `appt:confirm:<id>`
* **❌ Отклонить** → callback `appt:decline:<id>`

Организатору — уведомление о создании приглашения.

### Подтверждение/отклонение

`handlers_appointments.appointment_decision_handler`:

* проверяет, что кнопку жмёт **именно приглашённый**,
* меняет статус на `confirmed`/`declined`,
* уведомляет обе стороны,
* при отмене инициатором — перевод в `cancelled`.

### Ошибки доставки сообщений

Если участник **не начинал** чат с ботом (или «заблокировал бота»),
отправка упадёт с `Forbidden`. В этом случае:

* логируем ошибку,
* информируем организатора, что участнику нужно начать чат,
* встречу можно оставить `pending` или перевести в `cancelled` — по политике.

---

## Учёт статистики (BotStatistics)

Инкрементируются показатели за текущую дату:

* `track_event_created()` — после создания события
* `track_event_edited()` — после редактирования
* `track_event_cancelled()` — после удаления
* * персональные счётчики в `TgUser`: `created_total`, `edited_total`, `cancelled_total`

(Учёт по встречам можно добавить при необходимости.)

---

## Логирование

Используется стандартный `logging`. Логируются:

* входы в команды,
* шаги FSM (flow/step/данные),
* CRUD-операции с событиями,
* приглашения и callback-события.

Пример:

```
INFO tgapp.core: ensure_tg_user tg_id=123 created=True
INFO tgapp.handlers_events: CREATE step=WAIT_TIME msg=12:12
INFO tgapp.handlers_appointments: invite created appt_id=42 pending
INFO tgapp.handlers_appointments: appt confirm appt_id=42 by=987654321
```

---

## Примеры сценариев

### Создание события (FSM)

```
/create_event
→ Введите название события:
Встреча отдела
→ Введите дату в формате ГГГГ-ММ-ДД:
2025-12-12
→ Введите время в формате ЧЧ:ММ:
12:12
→ Введите описание события:
Планёрка по проекту X
→ Событие создано. ID: 2
```

### Редактирование одной строкой

```
/edit_event 2 Обновлённое описание
→ Обновлено.
```

### Удаление (FSM)

```
/delete_event
→ Введите ID события для удаления:
2
→ Удалено.
```

### Приглашение на встречу (FSM + inline)

```
/invite
→ Введите TG-ID участника:
777000
→ Введите ID события:
2
→ Введите детали (или напишите «Пропустить»):
Обсудим финальные сроки
→ Приглашение отправлено. Ожидается подтверждение участника.
```

Участнику:

```
Вас пригласили на встречу:
Дата/время: 2025-12-12 12:12
Детали: Обсудим финальные сроки
[ ✅ Подтвердить ] [ ❌ Отклонить ]
```

Организатору после клика участника:

```
Встреча #42 подтверждена участником @username.
```

или

```
Встреча #42 отклонена участником @username.
```

---

## Диаграммы

### Последовательность действий (sequence)

```mermaid
sequenceDiagram
  participant U as Пользователь (Организатор)
  participant B as Бот (FSM)
  participant DB as БД (PostgreSQL)
  participant DJ as Django ORM

  U->>B: /create_event (шаги FSM)
  B->>DB: INSERT INTO events (...)
  B-->>U: ID события

  U->>B: /invite (шаги FSM)
  B->>DJ: utils.is_user_free(participant, date, time)
  DJ->>DB: SELECT appointments ...
  alt Свободен
    B->>DJ: utils.create_pending_invite_for_event(...)
    DJ->>DB: INSERT appointment (pending)
    B-->>U: приглашение создано, ожидание
    B-->>participant: уведомление + inline-кнопки
  else Занят
    B-->>U: участник занят (сообщение)
  end

  participant->>B: Нажимает ✅/❌
  B->>DJ: update appointment status
  DJ->>DB: UPDATE appointment SET status=...
  B-->>U: уведомление об исходе
```

### Состояния приглашений (state)

```mermaid
stateDiagram-v2
  [*] --> INVITE_WAIT_PARTICIPANT
  INVITE_WAIT_PARTICIPANT --> INVITE_WAIT_EVENT_ID: валидный TG-ID
  INVITE_WAIT_PARTICIPANT --> [*]: /cancel

  INVITE_WAIT_EVENT_ID --> INVITE_WAIT_DETAILS: валидный event_id и владелец
  INVITE_WAIT_EVENT_ID --> [*]: /cancel

  INVITE_WAIT_DETAILS --> PENDING: create_pending_invite_for_event()
  INVITE_WAIT_DETAILS --> [*]: /cancel

  PENDING --> CONFIRMED: callback ✅
  PENDING --> DECLINED: callback ❌
  PENDING --> CANCELLED: инициатор отменил / ошибка доставки
  CONFIRMED --> [*]
  DECLINED --> [*]
  CANCELLED --> [*]
```

---

## Обработка ошибок

### Ошибки ввода

* Неверный формат даты/времени → дружелюбное сообщение с примером.
* Не число там, где нужен ID → просьба повторить ввод.
* Событие не принадлежит пользователю → запрет действия и подсказка.

### Ошибки БД

* Вставка/обновление неудачны — короткое сообщение пользователю и запись в лог.
* Критичные исключения — лог уровня `ERROR`.

### Ошибки Telegram API

* `Forbidden: bot was blocked by the user` / «чат не начат»:

  * логируем,
  * информируем организатора,
  * встречу оставляем `pending` или переводим в `cancelled` — по принятой политике.

---

## Тестирование

* Юнит-тесты парсеров даты/времени (`fsm.py`).
* Тесты FSM-веток: корректные переходы, `/cancel` на каждом шаге.
* Тесты CRUD-операций с событиями (через `db.py`) на локальной БД.
* Тесты приглашений:

  * свободный участник → `pending` → callback → `confirmed`;
  * занятый участник → корректный отказ;
  * недоставляемые сообщения → корректная деградация.
* Регресс-тесты для команд одной строкой (`/edit_event <id> ...`, `/delete_event <id>`).

---

## Требования к стилю и качеству кода

* PEP 8/257: docstring у модулей и функций, аннотации типов.
* Ясные имена состояний FSM и шагов.
* Логи: информативные, без чувствительных данных (токены/пароли).
* Исключения: не глушить, логировать и возвращать понятные сообщения.

---

## Частые вопросы

**Почему события из бота видны в админке Django?**
Обе части смотрят в **одну таблицу `events`**. В Django модель `Event` —
`managed=False` и `db_table="events"`, поэтому админка отражает те же данные.

**Почему `/invite` иногда «молчит» для участника?**
Если участник не начинал чат с ботом, Telegram не даст отправить ему сообщение.
Попросите участника написать боту любое сообщение.

**Можно ли хранить FSM не в памяти?**
Да: Redis / Postgres / файл. Для учебного проекта достаточно in-memory.

**Как изменить формат даты/времени?**
Обновить парсеры `parse_date/parse_time` в `fsm.py` и тексты подсказок.

---

## Чек-лист разработчика

* [ ] `bot_secrets.py` создан из `secrets_example.py`, токен валиден
* [ ] Подключение к БД в `db.py` соответствует реальной БД
* [ ] `/register`, `/login`, `/calendar` работают
* [ ] `/create_event`, `/display_events` отдают корректные данные
* [ ] `/edit_event` и `/delete_event`: оба режима (одной строкой и FSM)
* [ ] `/invite`: проверка владельца события и занятости участника
* [ ] Inline-кнопки подтверждения/отклонения работают, статусы обновляются
* [ ] Логи понятные, без секретов
* [ ] Ошибки Telegram API корректно обрабатываются и информируют организатора

---

## История изменений (кратко)

* **Часть 1**: базовый бот, CRUD событий через `db.py`, таблицы `users`/`events`.
* **Часть 2**: интеграция с Django:

  * учёт суточной статистики `BotStatistics` через ORM;
  * админка с отображением событий и статистики.
* **Часть 3**: встречи:

  * модель `Appointment` (Django ORM);
  * FSM-диалог `/invite`, проверка занятости, inline-кнопки;
  * уведомления организатору и участнику; статусы `pending/confirmed/declined/cancelled`.
* **Часть 4**: личные кабинеты:

  * модель `TgUser`, привязка `/login`, календарь `/calendar`,
  * персональные счётчики активности и inline-события в админке.

```