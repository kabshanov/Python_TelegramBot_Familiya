```md
# README_BOT — как работает Telegram-бот календаря

Этот документ описывает **телеграм-бот**: команды, диалоги (FSM), тексты ответов для пользователя, работу с БД, приглашения на встречи, публичные события, экспорт, логи и ошибки.

> Веб-часть (Django: модели, API/DRF, админка, экспортные эндпоинты) — смотрите `README_DJANGO.md`.  
> Общий обзор проекта и сборка окружения — в `README.md`.

---

## Оглавление

- [Возможности](#возможности)
- [Архитектура и файлы](#архитектура-и-файлы)
- [Запуск бота](#запуск-бота)
- [Подключение к БД](#подключение-к-бд)
- [Структура данных](#структура-данных)
  - [`users` (бот)](#users-бот)
  - [`events` (общая таблица)](#events-общая-таблица)
  - [`tg_users` / статистика / встречи (ORM)](#tg_users--статистика--встречи-orm)
- [Команды и поведение](#команды-и-поведение)
  - [`/start` / `/help`](#start--help)
  - [`/register`](#register)
  - [`/login`](#login)
  - [`/calendar` + кнопки экспорта](#calendar--кнопки-экспорта)
  - [`/create_event` (FSM)](#create_event-fsm)
  - [`/display_events`](#display_events)
  - [`/read_event <id>`](#read_event-id)
  - [`/edit_event` (строкой или FSM)](#edit_event-строкой-или-fsm)
  - [`/delete_event` (строкой или FSM)](#delete_event-строкой-или-fsm)
  - [`/share_event` (публичность)](#share_event-публичность)
  - [`/my_public` / `/public_of <tg_id>`](#my_public--public_of-tg_id)
  - [`/invite` (встречи, FSM)](#invite-встречи-fsm)
  - [`/export`](#export)
  - [`/cancel`](#cancel)
- [FSM: состояния и переходы](#fsm-состояния-и-переходы)
- [Экспорт: формат и безопасность](#экспорт-формат-и-безопасность)
- [Логирование](#логирование)
- [Ошибки и диагностика](#ошибки-и-диагностика)
- [Тестирование (Задание №9)](#тестирование-задание-9)
- [Интеграция с API/DRF (Задание №7)](#интеграция-с-apidrf-задание-7)
- [Чек-лист разработчика](#чек-лист-разработчика)

---

## Возможности

- CRUD событий календаря.
- Публичные события (`is_public`) и персональные списки.
- Экспорт личного календаря в **CSV/JSON** по подписанной ссылке.
- Приглашения на встречи с inline-кнопками подтверждения/отклонения.
- Связь с веб-панелью (профиль пользователя в Django).
- Логирование действий и мягкие тексты ответов для пользователя.

---

## Архитектура и файлы

```

project/
├─ bot.py                  # точка входа бота: Updater/Dispatcher, регистрация хендлеров, меню
├─ db.py                   # psycopg2: прямые SQL для users/events (общая PostgreSQL с Django)
├─ bot_secrets.py          # API_TOKEN (не коммитим), пример: secrets_example.py
└─ tgapp/
├─ **init**.py
├─ core.py              # общий логгер, меню, подсобные функции (счётчики/метрики)
├─ fsm.py               # простая in-memory FSM, парсеры даты/времени, клавиатуры «Отмена»
├─ handlers_events.py   # команды событий, публичность, календарь, экспорт, регистрация/логин
└─ handlers_appointments.py  # приглашения/встречи (FSM + inline-callback)

````

Принципы:

- Вся «бот-логика» лежит в `tgapp/*`, а `bot.py` — тонкий слой запуска.
- Бот пишет в БД **напрямую** через `db.py` (psycopg2) для `users` и `events`.
- Django читает эти же события через `Event(managed=False)`.
- Встречи/статистика/профили — через Django ORM (те же таблицы СУБД).

---

## Запуск бота

1) Создайте `bot_secrets.py` из шаблона и укажите `API_TOKEN`.  
2) Проверьте подключение к PostgreSQL (ниже).  
3) Из **корня** проекта:

```bash
python bot.py
````

> Важно: запускать **из корня** — так корректно подхватываются импорты и
> `DJANGO_SETTINGS_MODULE=webapp.settings` для ORM-частей.

---

## Подключение к БД

В `db.py` укажите:

```python
conn = psycopg2.connect(
    host="localhost",
    database="calendar_db",
    user="calendar_user",
    password="calendar_password",
)
```

Бот и Django используют **одну** БД. Таблица `events` — общая.

---

## Структура данных

### `users` (бот)

Минимальная таблица регистрации (заводится ботом / миграцией учебной БД):

* `tg_user_id BIGINT PRIMARY KEY`
* `username TEXT NULL`
* `first_name TEXT NULL`
* `created_at TIMESTAMP DEFAULT now()`

### `events` (общая таблица)

Используется **ботом** (вставка/обновление) и **Django** (чтение/админка):

* `id BIGSERIAL PRIMARY KEY`
* `user_id BIGINT NOT NULL` — владельц (TG-ID)
* `name VARCHAR(255) NOT NULL`
* `date DATE NOT NULL`
* `time TIME NOT NULL`
* `details TEXT NOT NULL DEFAULT ''`
* `is_public BOOLEAN NOT NULL DEFAULT FALSE`

### `tg_users` / статистика / встречи (ORM)

У Django есть модели:

* `TgUser (db_table="tg_users")` — профиль TG-пользователя,
  в том числе счётчики: `events_created / events_edited / events_cancelled`.
* `BotStatistics` — суточная статистика: количество новых пользователей и событий.
* `Appointment` — встречи (организатор/участник, статус `pending/confirmed/...`), с FK на `Event` без DB-констрейнта.

---

## Команды и поведение

### `/start` / `/help`

Короткая справка по возможностям:

* регистрация/логин;
* создание/просмотр/редактирование/удаление событий;
* публичные события и списки;
* экспорт CSV/JSON;
* приглашения на встречи;
* `/cancel` — отмена любого диалога.

Тон сообщений — дружелюбный, без «внутренних полей» вроде `is_public=True`.

### `/register`

Идемпотентно регистрирует TG-пользователя (таблица `users`), синхронизирует профиль `TgUser` (ORM).

### `/login`

Привязывает текущий аккаунт TG к профилю `TgUser` (создаёт/активирует в админке).

### `/calendar` + кнопки экспорта

Показывает **личные** события пользователя и выдаёт inline-кнопки:

* **⬇️ CSV** → `/export/csv/?token=...`
* **⬇️ JSON** → `/export/json/?token=...`

Ссылки содержат **подписанный токен** (см. раздел «Экспорт»).

### `/create_event` (FSM)

Диалог: **Название → Дата (`YYYY-MM-DD`) → Время (`HH:MM`) → Описание**.
Результат: «Событие создано. ID: …». Обновляются суточная статистика и личные счётчики.

### `/display_events`

Краткий список ваших событий:

```
[ID: 7] Демо — 2025-12-12 12:12
[ID: 8] …
```

### `/read_event <id>`

Подробности **своего** события по ID. Чужие — не показываются.

### `/edit_event` (строкой или FSM)

* Строкой: `/edit_event <id> <новое описание>`
* FSM: `/edit_event` → спросит ID → проверит владение → спросит описание → обновит.

### `/delete_event` (строкой или FSM)

* Строкой: `/delete_event <id>`
* FSM: спросит ID → удалит, если событие ваше.

### `/share_event` (публичность)

Команда переключает флаг `is_public` события пользователю:

* спросит ID;
* проверит, что событие ваше;
* переключит и ответит **человеческим текстом**:

  * «Событие теперь **публичное** — им можно делиться»
  * / «Событие **снова приватное**».

### `/my_public` / `/public_of <tg_id>`

* `/my_public` — ваши публичные события.
* `/public_of 777000` — публичные события другого пользователя.

Вывод компактный: `[ID: …] Название — Дата Время`.

### `/invite` (встречи, FSM)

Диалог приглашения:

1. TG-ID участника → 2) ID вашего события → 3) детали/«Пропустить».

Проверяется, что слот у участника свободен (учитываются `pending/confirmed`).
Участнику уходит inline-сообщение: **✅ Подтвердить** / **❌ Отклонить**.
Организатор видит уведомление «Ожидаем ответ».

### `/export`

Генерирует две ссылки (CSV/JSON) с **подписанным токеном** для владельца календаря.
Кнопки экспорта доступны также в `/calendar`.

### `/cancel`

Отменяет любой активный диалог, очищает состояние.

---

## FSM: состояния и переходы

Хранение в памяти процесса (`tgapp/fsm.py`):

* **CREATE**: `WAIT_NAME → WAIT_DATE → WAIT_TIME → WAIT_DETAILS → INSERT`
* **EDIT**: `WAIT_ID → WAIT_NEW_DETAILS → UPDATE`
* **DELETE**: `WAIT_ID → DELETE`
* **SHARE**: `SHARE_WAIT_EVENT_ID → toggle is_public`
* **INVITE**: `INVITE_WAIT_PARTICIPANT → INVITE_WAIT_EVENT_ID → INVITE_WAIT_DETAILS → create pending`

На каждом шаге действует `/cancel`.

---

## Экспорт: формат и безопасность

* **Токен**: формируется в Django утилитой `make_export_token(user_tg_id)`.

  * TTL задаётся `settings.EXPORT_TOKEN_MAX_AGE` (секунды), дефолт — `900`.
  * Ссылка валидна **только** для владельца (по подписи и tg_id).
* **CSV**:

  * кодировка: **CP1251** (Windows-совместимость);
  * разделитель: **`;`** (точка с запятой);
  * **без** строки `sep=;` в заголовке;
  * заголовок: `id;name;date;time;details`.
* **JSON**: массив объектов `{id, name, date, time, details}`.

---

## Логирование

Единый формат:

```
%(asctime)s [%(levelname)s] %(name)s: %(message)s
```

Основные логгеры:

* `calendar_bot` — точка входа/инициализация.
* `db` — SQL-уровень (подключение, CRUD).
* `tgapp.handlers_events` / `tgapp.handlers_appointments` — команды, шаги FSM, итоги операций.

Что логируем:

* вход в команды (`/start`, `/create_event`, `/share_event`, `/export`…);
* шаги FSM (flow/step/ввод, без секретов);
* результаты (`created id=…`, `is_public=True/False`, `invite sent`…);
* ошибки БД и Telegram API.

---

## Ошибки и диагностика

* **`Conflict: terminated by other getUpdates request`** — запущено два экземпляра бота. Остановите лишний процесс.
* **`ModuleNotFoundError: webapp.settings`** — бот запущен не из корня проекта. Запускайте `python bot.py` в корне.
* **Недоступна БД** — проверьте параметры в `db.py`, доступ `psql`, пользователя и пароль.
* **CSV «кракозябры»** — откройте файл как CP1251 или импортируйте в Excel/LibreOffice с указанием кодировки и разделителя `;`.

---

## Тестирование (Задание №9)

Минимальный, но показательный набор тестов покрытия «критических узлов»:

* модели/ORM: создание пользователя, встреч, счётчиков;
* экспорт представлений: JSON/CSV (валидность формата);
* базовые хендлеры бота (`/start`/`/help`) — корректный текст ответа.

Запуск из корня:

```bash
pytest --reuse-db
```

> Требуется запущенный PostgreSQL и доступ к тестовой БД.
> При первом запуске тесты создадут необходимые таблицы.

---

## Интеграция с API/DRF (Задание №7)

Бот генерирует ссылки экспорта, которые обслуживает веб-приложение (Django + DRF):

* эндпоинты `/export/csv/` и `/export/json/` принимают `token=...`;
* токен валидируется, данные событий формируются из таблицы `events`.

Подробная схема сериализаторов, вьюшек и URL — в `README_DJANGO.md`.

---

## Чек-лист разработчика

* [ ] `bot_secrets.py` создан, `API_TOKEN` валиден.
* [ ] `db.py` указывает на ту же PostgreSQL, что и Django.
* [ ] `/register` и `/login` отрабатывают без ошибок.
* [ ] CRUD событий: `/create_event`, `/display_events`, `/read_event`, `/edit_event`, `/delete_event`.
* [ ] Публичность: `/share_event`, списки `/my_public`, `/public_of`.
* [ ] Экспорт: `/calendar` показывает кнопки; ссылки открываются и возвращают корректный CSV/JSON.
* [ ] Приглашения: `/invite` создаёт `pending`, inline-кнопки работают.
* [ ] Логи информативные, нет «утечки» секретов в логах.
* [ ] Тесты (`pytest --reuse-db`) проходят локально.

```