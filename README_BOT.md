```md
# README_BOT — как работает Telegram-бот календаря

Документ описывает **исключительно работу телеграм-бота**:
команды, диалоги (FSM), форматы сообщений и inline-кнопок,
взаимодействие с БД, учёт статистики, приглашения на встречи,
публичные события и экспорт календаря, а также обработку ошибок и логи.

> Веб-часть (Django: админка, модели, миграции, экспортные эндпоинты)
> — в `README_DJANGO.md`. Общий обзор проекта — в `README.md`.

---

## Оглавление

- [Краткое описание](#краткое-описание)
- [Архитектура бота](#архитектура-бота)
  - [Основные файлы и пакеты](#основные-файлы-и-пакеты)
  - [Зависимости](#зависимости)
  - [Обзор потоков данных](#обзор-потоков-данных)
- [Конфигурация и запуск](#конфигурация-и-запуск)
  - [`bot_secrets.py`](#bot_secretspy)
  - [Параметры БД](#параметры-бд)
  - [Запуск](#запуск)
  - [Меню команд](#меню-команд)
- [База данных](#база-данных)
  - [`users`](#users)
  - [`events` + `is_public`](#events--is_public)
- [Команды бота](#команды-бота)
  - [`/start`, `/help`](#start-help)
  - [`/register`](#register)
  - [`/login`](#login)
  - [`/calendar` (+ кнопки экспорта)](#calendar--кнопки-экспорта)
  - [`/create_event` (FSM)](#create_event-fsm)
  - [`/display_events`](#display_events)
  - [`/read_event <id>`](#read_event-id)
  - [`/edit_event` (одной строкой или FSM)](#edit_event-одной-строкой-или-fsm)
  - [`/delete_event` (одной строкой или FSM)](#delete_event-одной-строкой-или-fsm)
  - [`/invite` (FSM приглашений)](#invite-fsm-приглашений)
  - [`/share_event` (публичность события)](#share_event-публичность-события)
  - [`/my_public` и `/public_of`](#my_public-и-public_of)
  - [`/export`](#export)
  - [`/cancel`](#cancel)
- [FSM — состояния, переходы, отмена](#fsm--состояния-переходы-отмена)
  - [События (создание/редактирование/удаление)](#события-созданиередактированиеудаление)
  - [Приглашения](#приглашения)
  - [Публичность события](#публичность-события)
- [Встречи (Appointments)](#встречи-appointments)
  - [Проверка занятости](#проверка-занятости)
  - [Создание и уведомления](#создание-и-уведомления)
  - [Подтверждение/отклонение](#подтверждениеотклонение)
- [Учёт статистики и счётчики](#учёт-статистики-и-счётчики)
- [Логирование](#логирование)
- [Примеры сценариев](#примеры-сценариев)
- [Обработка ошибок](#обработка-ошибок)
- [Тестирование](#тестирование)
- [Требования к стилю кода](#требования-к-стилю-кода)
- [ЧаВо](#чаво)
- [Чек-лист разработчика](#чек-лист-разработчика)

---

## Краткое описание

Бот позволяет пользователю:

- управлять событиями календаря (создание, просмотр, редактирование, удаление);
- назначать встречи другим пользователям (с проверкой занятости, inline-подтверждением);
- привязать Telegram-аккаунт к веб-панели (личный кабинет в админке Django);
- **делиться событиями** (флаг `is_public`);
- **выгружать** свои события в **CSV/JSON** (защищённые ссылки из `/calendar` или `/export`).

---

## Архитектура бота

### Основные файлы и пакеты

```

project/
├─ bot.py                      # точка входа: Updater/Dispatcher, регистрация хендлеров, меню
├─ db.py                       # psycopg2: подключение и CRUD users/events (общая PostgreSQL с Django)
├─ bot_secrets.py              # API_TOKEN (не коммитим) — см. secrets_example.py
└─ tgapp/
├─ **init**.py              # пояснительный docstring пакета (без кода)
├─ core.py                  # логгер, меню, учёт статистики/счётчиков, вспомогательные функции
├─ fsm.py                   # простая in-memory FSM + парсеры даты/времени, клавиатуры "Отмена"
├─ handlers_events.py       # события, публичность, календарь, экспорт, логин/регистрация
└─ handlers_appointments.py # приглашения/встречи (FSM + inline-callback)

````

**Принципы:**

- `bot.py` — тонкий слой запуска и маршрутизации; логика в `tgapp/*`.
- События и пользователи → `db.py` (чистый SQL через psycopg2).
- Встречи, статистика, счётчики, публичные выборки для UI → Django ORM (те же таблицы).
- FSM хранится в памяти процесса (для учебной задачи достаточно).

### Зависимости

- `python-telegram-bot==13.x`
- `psycopg2-binary`
- `Django 5.x`
- `djangorestframework` (задел)
- `logging` стандартный

### Обзор потоков данных

- **События**: бот ↔ `db.py` ↔ PostgreSQL (таблица `events`), Django читает через `Event(managed=False)`.
- **Встречи**: бот ↔ Django ORM (`Appointment`) ↔ PostgreSQL.
- **Профили и счётчики**: бот ↔ Django ORM (`TgUser`, `BotStatistics`) ↔ PostgreSQL.
- **Экспорт**: бот генерирует подписанную ссылку → Django-эндпоинт отдаёт CSV/JSON.

---

## Конфигурация и запуск

### `bot_secrets.py`

```python
# bot_secrets.py
API_TOKEN = "1234567890:ABCDEF..."
````

Файл в `.gitignore`. Пример — `secrets_example.py`.

### Параметры БД

В `db.py` задайте параметры подключения к **той же** PostgreSQL, что использует Django:
имя БД, пользователь, пароль, хост, порт.

### Запуск

Из **корня** проекта:

```bash
python bot.py
```

> Важно запускать из корня: корректные импорты и переменная
> `DJANGO_SETTINGS_MODULE=webapp.settings` для ORM.

### Меню команд

Бот выставляет меню `/start`, `/help`, `/register`, `/login`, `/calendar`,
`/create_event`, `/display_events`, `/read_event`, `/edit_event`, `/delete_event`,
`/invite`, **`/share_event`**, **`/my_public`**, **`/public_of`**, **`/export`**, `/cancel`.

---

## База данных

### `users`

Минимальная таблица для регистрации ID пользователя (через `/register`):

* `tg_user_id BIGINT PRIMARY KEY`
* `username TEXT NULL`
* `first_name TEXT NULL`
* `created_at TIMESTAMP DEFAULT now()`

### `events` + `is_public`

Таблица общая для бота и Django:

* `id SERIAL PRIMARY KEY`
* `name VARCHAR(255) NOT NULL`
* `date DATE NOT NULL`
* `time TIME NOT NULL`
* `details TEXT NOT NULL DEFAULT ''`
* `user_id BIGINT NOT NULL` — владелец (Telegram ID)
* **`is_public BOOLEAN NOT NULL DEFAULT false`** — флаг публичности (Task 5)

Бот создаёт/изменяет записи напрямую (psycopg2). Django видит их через
модель `Event(managed=False, db_table="events")`.

---

## Команды бота

### `/start`, `/help`

Сводка по доступным возможностям:

* регистрация / личный кабинет,
* управление событиями,
* встречи,
* **публичные события**,
* **экспорт** CSV/JSON,
* `/cancel` для отмены любого диалога.

### `/register`

Идемпотентно создаёт пользователя в `users` (если уже есть — подтверждает без ошибки).
Параллельно создаёт/обновляет карточку `TgUser` в Django (личный кабинет).

### `/login`

Привязывает текущий Telegram к `TgUser` (создаёт/обновляет профиль и включает его в админке).

### `/calendar` (+ кнопки экспорта)

Показывает **личный календарь** (ORM `Event` по `tg_user_id`) и
даёт кнопки:

* **⬇️ CSV** — ссылка на Django-эндпоинт `/export/csv/?token=...`
* **⬇️ JSON** — `/export/json/?token=...`

Ссылки содержат **подписанный токен** (TTL по `settings.EXPORT_TOKEN_MAX_AGE`),
поэтому выгрузить может **только владелец**.

### `/create_event` (FSM)

Пошагово:

1. Название → 2) Дата (`YYYY-MM-DD`) → 3) Время (`HH:MM`) → 4) Описание → запись в `events`.

На успех выводится «Событие создано. ID: …». Обновляются суточная статистика и
персональные счётчики пользователя.

### `/display_events`

Краткий список своих событий:

```
[ID: 7] Встреча — 2025-12-12 12:12
[ID: 8] …
```

### `/read_event <id>`

Показывает подробности события **только владельца**. Чужие — запрещены.

### `/edit_event` (одной строкой или FSM)

* Одной строкой: `/edit_event <id> <новое описание>`
* FSM: без аргументов → попросит ID → проверит владение → попросит новое описание → обновит.

При успехе: сообщение об обновлении + инкремент счётчиков.

### `/delete_event` (одной строкой или FSM)

* Одной строкой: `/delete_event <id>`
* FSM: без аргументов → спросит ID → удалит, если ваше.

При успехе: сообщение об удалении + инкремент счётчиков отмен.

### `/invite` (FSM приглашений)

Диалог приглашения участника на **ваше** событие:

1. TG-ID участника → 2) ID вашего события → 3) детали/«Пропустить».

Проверяется:

* что событие — ваше;
* что участник свободен на слоте (см. [Проверка занятости](#проверка-занятости)).

Если свободен — создаётся `Appointment(status=pending)`, участнику уходит
уведомление с inline-кнопками **«✅ Подтвердить»** / **«❌ Отклонить»**,
организатору — уведомление «Ожидаем ответ».

### `/share_event` (публичность события)

Команда делает событие **публичным** (или **снимает** публичность),
работает через простой FSM:

* запросит ID события (покажет подсказку, как посмотреть список),
* проверит владение,
* переключит `is_public` и выдаст дружелюбный ответ:

  * «Событие теперь **публичное** — им можно делиться»
  * или «Событие **снова приватное**».

(Если хотите строго «только включать», валидацию можно изменить на «только `False→True`».)

### `/my_public` и `/public_of`

* `/my_public` — показывает **мои публичные** события (фильтр по `tg_user_id` и `is_public=TRUE`).
* `/public_of <tg_id_владельца>` — показывает публичные события **другого** пользователя.

> Вывод компактный (ID/дата/время/название). Чужие непубличные события не видны.

### `/export`

Генерирует **подписанные ссылки** на выгрузку календаря владельца:

* CSV: `/export/csv/?token=...`
* JSON: `/export/json/?token=...`

Кнопки экспорта также доступны в `/calendar`.

### `/cancel`

Отменяет **любой** текущий диалог FSM и очищает состояние.
Всегда доступна кнопка «Отмена».

---

## FSM — состояния, переходы, отмена

Хранение в памяти процесса:

```python
user_states = {
  tg_id: {"flow": "CREATE" | "EDIT" | "DELETE" | "INVITE" | "SHARE",
          "step": "...",
          "data": {...}}
}
```

Операции: `set_state`, `get_state`, `clear_state` — в `tgapp/fsm.py`.

### События (создание/редактирование/удаление)

* `CREATE`: `WAIT_NAME` → `WAIT_DATE` → `WAIT_TIME` → `WAIT_DETAILS` → INSERT
* `EDIT`: `WAIT_ID` → `WAIT_NEW_DETAILS` → UPDATE
* `DELETE`: `WAIT_ID` → DELETE

### Приглашения

* `INVITE`: `INVITE_WAIT_PARTICIPANT` → `INVITE_WAIT_EVENT_ID` → `INVITE_WAIT_DETAILS` → create pending

### Публичность события

* `SHARE`: `SHARE_WAIT_EVENT_ID` → переключение `is_public` (True/False) → финальный ответ

> На каждом шаге `/cancel` — выход и очистка состояния.

---

## Встречи (Appointments)

### Проверка занятости

Используется утилита ORM: pending/confirmed слоты считаются занятыми.

### Создание и уведомления

При успешной проверке создаётся `Appointment(pending)`,
участнику уходит приглашение с inline-кнопками, организатор получает
подтверждение создания приглашения.

### Подтверждение/отклонение

Callback-хендлер принимает `appt:confirm:<id>` / `appt:decline:<id>`,
валидирует «кто нажал», меняет статус на `confirmed/declined`, уведомляет обе стороны.

---

## Учёт статистики и счётчики

* Суточная статистика `BotStatistics`:

  * `track_event_created()`, `track_event_edited()`, `track_event_cancelled()`.
* Персональные счётчики `TgUser`:

  * `created_total`, `edited_total`, `cancelled_total`.

Обновляются в соответствующих точках `handlers_events.py`.

---

## Логирование

Используется стандартный `logging` (единый логгер модуля). Логируем:

* входы в команды;
* шаги FSM (flow/step/данные — без чувствительных полей);
* CRUD событий и переключение `is_public`;
* приглашения и callback-решения;
* генерацию экспортных ссылок;
* ошибки БД / Telegram API.

Пример строк:

```
INFO tgapp.handlers_events: /share_event by=667400736
INFO tgapp.handlers_events: SHARE step=WAIT_EVENT_ID msg=5
INFO tgapp.handlers_events: event 5 is_public=True owner=667400736
INFO tgapp.handlers_events: /export links for=667400736
```

---

## Примеры сценариев

**Создание события (FSM)**

```
/create_event
→ Введите название события:
Демо-звонок
→ Введите дату в формате ГГГГ-ММ-ДД:
2025-12-12
→ Введите время в формате ЧЧ:ММ:
12:12
→ Введите описание события:
Обсудим задачи
→ Событие создано. ID: 17
```

**Сделать событие публичным**

```
/share_event
→ Введите ID события, которым хотите поделиться:
17
→ Событие теперь публичное — им можно делиться.
```

**Посмотреть публичные события другого пользователя**

```
/public_of 777000
→ Публичные события пользователя 777000:
[ID: 42] Митап — 2025-10-10 18:00
...
```

**Экспорт**

```
/export
→ Получите свои выгрузки:
[ ⬇️ CSV ] [ ⬇️ JSON ]
```

**Приглашение на встречу**

```
/invite
→ Введите TG-ID участника:
777000
→ Введите ID события:
17
→ Введите детали (или напишите «Пропустить»):
Коротко сверимся по задачам
→ Приглашение отправлено. Ждём ответа участника.
```

---

## Обработка ошибок

* Неверные форматы даты/времени/ID — дружелюбные подсказки + пример.
* Чужой `event_id` — вежливый отказ: «Это событие вам не принадлежит».
* При недоступности БД — краткое сообщение пользователю, запись `ERROR` в лог.
* Telegram `Forbidden` (участник не начинал чат/заблокировал бота) — логируем и уведомляем организатора.

---

## Тестирование

* Юнит-тесты парсеров даты/времени (`fsm.py`).
* FSM ветки: корректные переходы и `/cancel` на каждом шаге.
* CRUD событий через `db.py` на локальной БД.
* `share_event`: переключение `is_public`, корректные тексты.
* Экспорт: `/calendar` и `/export` выдают валидные ссылки (CSV/JSON открываются в браузере).
* Приглашения: свободный/занятый участник, подтверждение/отклонение.

---

## Требования к стилю кода

* PEP-8/257: аннотации типов, docstring у функций/модулей.
* Называние состояний FSM — явное и единообразное.
* Логи — информативны, без секретов (не логировать токены/пароли).

---

## ЧаВо

**Почему событие видно в админке Django?**
Бот и Django используют **одну** таблицу `events`. В Django модель `Event` — `managed=False`.

**Почему у меня нет кнопок экспорта в `/calendar`?**
См. актуальную версию `handlers_events.py`: команда добавляет InlineKeyboard со ссылками CSV/JSON.
Если кнопок нет — проверьте импорты и `reverse` URL в Django.

**Почему `/public_of` ничего не показывает?**
Либо у указанного пользователя нет публичных событий, либо вы указали неверный TG-ID.

---

## Чек-лист разработчика

* [ ] `bot_secrets.py` создан из шаблона, токен валиден
* [ ] Настроен `db.py` и доступ к PostgreSQL
* [ ] `/register`, `/login` отрабатывают без ошибок
* [ ] `/create_event`, `/display_events`, `/read_event`, `/edit_event`, `/delete_event` работают
* [ ] `/invite` создаёт `pending` и даёт inline-кнопки участнику
* [ ] `/share_event` корректно переключает `is_public` и пишет понятные сообщения
* [ ] `/my_public`, `/public_of` отдают ожидаемые списки
* [ ] `/calendar` показывает события и кнопки **CSV/JSON**
* [ ] `/export` формирует рабочие ссылки; Django-эндпоинты отдают файлы
* [ ] Логи информативные; ошибки обрабатываются дружелюбно

```